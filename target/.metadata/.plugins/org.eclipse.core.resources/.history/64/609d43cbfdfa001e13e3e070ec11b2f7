/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "gpio_ports.h"

void dim_led(GPIOPort *port, int ledPin, int ratioHigh, int cycleNbr, int shutDownfinal)
{
	uint64_t ticks_cntr 		= 0;
	uint64_t prev_ticks_cntr	= 0;
	int dim_delay 				= 1000;

	while(ticks_cntr <= cycleNbr)
	{
		// When delay is reached, set the pin to HIGH
		if(ticks_cntr - prev_ticks_cntr >= dim_delay)
		{
			setPin(port, ledPin);

			// Update previous tick counter
			prev_ticks_cntr = ticks_cntr;
		}
		if(ticks_cntr - prev_ticks_cntr >= ratioHigh)
			clearPin(port, ledPin);

		ticks_cntr++;
	}
	if (shutDownfinal)
		// Shut down LED before to leave
		clearPin(port, ledPin);
}

void pulse_led(GPIOPort *port, int ledPin)
{
	for(;;)
	{
		int ratioHigh = 1000;
		int ratioEvolution = 1;
		dim_led(port, ledPin, ratioHigh, 10000, 0);
		if (ratioEvolution)
		{
			ratioHigh++;
		} else {
			ratioHigh--;
		}
		if (ratioHigh >= 1000)
			ratioEvolution = 0;
		if (ratioHigh <= 0)
			ratioEvolution = 1;
	}
}

int main(void)
{
	/*uint64_t ticks_cntr 		= 0;
	uint64_t prev_ticks_cntr	= 0;
	int led_state 				= 0;
	int delay_in_ticks 			= 25000;
	int min_delay 				= 1000;
	int max_delay 				= 50000;
	int delay_evolution 		= 1;*/
	const int LEDPIN 			= 13;

	printf("Initializing GPIO port %c...\n", GPIOPortB.portIndex);
	activatePort(&GPIOPortB);
	selectPinFunction(&GPIOPortB, LEDPIN, 1);
	printf("GPIO port %c initialized.\n", GPIOPortB.portIndex);

	//uint64_t ticks_cntr 		= 0;
	//uint64_t prev_ticks_cntr	= 0;
	//float ratio_HIGH 			= 0.1;
	//int dim_delay 				= 1000;
	//setPin(&GPIOPortB, LEDPIN);

	pulse_led(&GPIOPortB, LEDPIN);
	/*for(;;)
	{
		// When delay is reached, set the pin to HIGH
		if(ticks_cntr - prev_ticks_cntr >= dim_delay)
		{
			setPin(&GPIOPortB, LEDPIN);

			// Update previous tick counter
			prev_ticks_cntr = ticks_cntr;
		}
		if(ticks_cntr - prev_ticks_cntr >= 10)
			clearPin(&GPIOPortB, LEDPIN);

		ticks_cntr++;
	}*/
    /* Loop forever */
	/*for(;;)
	{
		// When delay is reached, set the pin as expected
		if(ticks_cntr - prev_ticks_cntr >= delay_in_ticks)
		{
			// If LED is HIGH, set it LOW
			if(led_state == 1)
			{
				clearPin(&GPIOPortB, LEDPIN);
				led_state = 0;
			} else { // Else set it HIGH.
				setPin(&GPIOPortB, LEDPIN);
				led_state = 1;
			}
			// Update previous tick counter
			prev_ticks_cntr = ticks_cntr;

			if(delay_in_ticks >= max_delay)
			{
				delay_evolution = 1;
				printf("Max delay reached, decreasing...\n");
			} else if(delay_in_ticks <= min_delay)
			{
				delay_evolution = 0;
				printf("Min delay reached, increasing...\n");
			}
			if(delay_evolution)
				delay_in_ticks -= 100;
			else
				delay_in_ticks += 100;
		}

		ticks_cntr++;
	}*/
}
